From d94b874ff7683086552138e666d6711ae2f75636 Mon Sep 17 00:00:00 2001
From: Matthijs van Duin <matthijsvanduin@gmail.com>
Date: Wed, 17 Jan 2018 11:50:01 +0100
Subject: [PATCH 9/9] fiddling with cpts

---
 drivers/net/ethernet/ti/cpts.c | 75 ++++++++++++++++++++++--------------------
 net/packet/af_packet.c         |  4 +++
 2 files changed, 43 insertions(+), 36 deletions(-)

diff --git a/drivers/net/ethernet/ti/cpts.c b/drivers/net/ethernet/ti/cpts.c
index e08ff12a72ea..4510f4152276 100644
--- a/drivers/net/ethernet/ti/cpts.c
+++ b/drivers/net/ethernet/ti/cpts.c
@@ -59,69 +59,72 @@ static int cpts_fifo_pop(struct cpts *cpts, u32 *high, u32 *low)
 	return -1;
 }
 
-/*
- * Returns zero if matching event type was found.
- */
-static int cpts_fifo_read(struct cpts *cpts, int match)
+static void cpts_queue_event(struct cpts *cpts, u32 hi, u32 lo)
+{
+	struct cpts_event *event;
+
+	if (list_empty(&cpts->pool)) {
+		// drop oldest event
+		event = list_first_entry(&cpts->events,
+				struct cpts_event, list);
+		if (!event_expired(event))
+			pr_err("cpts: event pool is empty, dropping event\n");
+	} else {
+		event = list_first_entry(&cpts->pool, struct cpts_event, list);
+	}
+	event->tmo = jiffies + 2;
+	event->high = hi;
+	event->low = lo;
+	list_move_tail(&event->list, &cpts->events);
+}
+
+static int cpts_fifo_read(struct cpts *cpts, u32 *pushed)
 {
 	int i, type = -1;
 	u32 hi, lo;
-	struct cpts_event *event;
 
 	for (i = 0; i < CPTS_FIFO_DEPTH; i++) {
 		if (cpts_fifo_pop(cpts, &hi, &lo))
 			break;
-		if (list_empty(&cpts->pool)) {
-			pr_err("cpts: event pool is empty\n");
-			return -1;
-		}
-		event = list_first_entry(&cpts->pool, struct cpts_event, list);
-		event->tmo = jiffies + 2;
-		event->high = hi;
-		event->low = lo;
-		type = event_type(event);
+		type = (hi >> EVENT_TYPE_SHIFT) & EVENT_TYPE_MASK;
 		switch (type) {
 		case CPTS_EV_PUSH:
+			if (pushed) {
+				*pushed = lo;
+				return 0;
+			}
+			pr_err("cpts: unexpected push event\n");
+			break;
 		case CPTS_EV_RX:
 		case CPTS_EV_TX:
-			list_del_init(&event->list);
-			list_add_tail(&event->list, &cpts->events);
+			cpts_queue_event(cpts, hi, lo);
 			break;
 		case CPTS_EV_ROLL:
 		case CPTS_EV_HALF:
+			break;
 		case CPTS_EV_HW:
+			pr_debug("cpts: hw event %d ts %u\n",
+				(hi >> PORT_NUMBER_SHIFT) & PORT_NUMBER_MASK,
+				lo);
 			break;
 		default:
 			pr_err("cpts: unknown event type\n");
 			break;
 		}
-		if (type == match)
-			break;
 	}
-	return type == match ? 0 : -1;
+	return -1;
 }
 
 static cycle_t cpts_systim_read(const struct cyclecounter *cc)
 {
-	u64 val = 0;
-	struct cpts_event *event;
-	struct list_head *this, *next;
+	u32 val = 0;
 	struct cpts *cpts = container_of(cc, struct cpts, cc);
 
+	cpts_fifo_read(cpts, NULL);
 	cpts_write32(cpts, TS_PUSH, ts_push);
-	if (cpts_fifo_read(cpts, CPTS_EV_PUSH))
+	if (cpts_fifo_read(cpts, &val))
 		pr_err("cpts: unable to obtain a time stamp\n");
 
-	list_for_each_safe(this, next, &cpts->events) {
-		event = list_entry(this, struct cpts_event, list);
-		if (event_type(event) == CPTS_EV_PUSH) {
-			list_del_init(&event->list);
-			list_add(&event->list, &cpts->pool);
-			val = event->low;
-			break;
-		}
-	}
-
 	return val;
 }
 
@@ -223,8 +226,8 @@ static void cpts_overflow_check(struct work_struct *work)
 	struct timespec64 ts;
 	struct cpts *cpts = container_of(work, struct cpts, overflow_work.work);
 
-	cpts_write32(cpts, CPTS_EN, control);
-	cpts_write32(cpts, TS_PEND_EN, int_enable);
+//	cpts_write32(cpts, CPTS_EN, control);
+//	cpts_write32(cpts, TS_PEND_EN, int_enable);
 	cpts_ptp_gettime(&cpts->info, &ts);
 	pr_debug("cpts overflow check at %lld.%09lu\n", ts.tv_sec, ts.tv_nsec);
 	schedule_delayed_work(&cpts->overflow_work, CPTS_OVERFLOW_PERIOD);
@@ -297,7 +300,7 @@ static u64 cpts_find_ts(struct cpts *cpts, struct sk_buff *skb, int ev_type)
 		return 0;
 
 	spin_lock_irqsave(&cpts->lock, flags);
-	cpts_fifo_read(cpts, CPTS_EV_PUSH);
+	cpts_fifo_read(cpts, NULL);
 	list_for_each_safe(this, next, &cpts->events) {
 		event = list_entry(this, struct cpts_event, list);
 		if (event_expired(event)) {
diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index b17f9097c6fe..4f470bf9c00d 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -2936,6 +2936,10 @@ static int packet_snd(struct socket *sock, struct msghdr *msg, size_t len)
 		goto out_free;
 	}
 
+	if (skb_shinfo(skb)->tx_flags & SKBTX_ANY_TSTAMP &&
+	    sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)
+		skb_shinfo(skb)->tskey = sk->sk_tskey++;
+
 	skb->protocol = proto;
 	skb->dev = dev;
 	skb->priority = sk->sk_priority;
-- 
2.11.0

